{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-8c5f10c8c7cce48ee83d0fd3abe2129f537b1382",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/SkillVerification.sol": "project/contracts/SkillVerification.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/SkillVerification.sol": {
        "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ncontract SkillVerification {\n    address public owner;\n    address public resolver;\n\n    // Predefined stake amount: 0.01 ETH\n    uint256 public constant PREDEFINED_STAKE_AMOUNT = 0.01 ether;\n\n    // Time constants\n    uint256 public constant PROBLEM_SOLVING_TIME = 2 hours;\n    uint256 public constant CHALLENGE_WINDOW = 72 hours;\n\n    // Status: 0=Pending, 1=Challenged, 2=Verified, 3=Rejected\n    enum Status {\n        PENDING,\n        CHALLENGED,\n        VERIFIED,\n        REJECTED\n    }\n\n    struct SkillClaim {\n        address user;\n        string skillId; // e.g., \"React\", \"Solidity\"\n        uint256 stakeAmount;\n        Status status;\n        uint256 claimTimestamp;\n        uint256 problemDeadline; // When the problem solving period ends\n        uint256 challengeDeadline; // When the challenge window ends\n        bool problemSolved; // Whether the claimant solved the problem\n        string problemStatement; // The problem they need to solve (provided by platform)\n        string solution; // The claimant's solution\n    }\n\n    struct Challenge {\n        address challenger;\n        uint256 stakeAmount;\n        string reason;\n        uint256 claimId;\n        uint256 challengeTimestamp;\n    }\n\n    struct ResolverVote {\n        address resolver;\n        bool supportsClaimant; // true = claimant wins, false = challenger wins\n        string reasoning;\n        uint256 timestamp;\n    }\n\n    // Events\n    event ClaimStaked(address indexed user, uint256 indexed claimId, string skillId, uint256 stakeAmount, string problemStatement);\n    event ProblemSolved(uint256 indexed claimId, string solution);\n    event ClaimChallenged(address indexed challenger, uint256 indexed claimId, string reason, uint256 stakeAmount);\n    event ResolverVoted(address indexed resolver, uint256 indexed claimId, bool supportsClaimant, string reasoning);\n    event ChallengeResolved(uint256 indexed claimId, bool claimantWon, address winner, uint256 totalAmount);\n    event SkillVerified(address indexed user, string skillId);\n    event SkillAdded(string skillId, string problemStatement);\n    event SkillRemoved(string skillId);\n    event ResolverUpdated(address indexed oldResolver, address indexed newResolver);\n    event StakeDistributed(uint256 indexed claimId, address indexed winner, uint256 winnerAmount, uint256 platformAmount, uint256 resolverAmount);\n    event SkillDirectlyAssigned(address indexed user, string skillId, address indexed assignedBy);\n\n    // State Variables\n    mapping(uint256 => SkillClaim) public claims;\n    mapping(uint256 => Challenge) public challenges;\n    mapping(uint256 => ResolverVote[]) public resolverVotes; // claimId => votes\n    mapping(string => address[]) public verifiedSkills; // skillId => userAddress[]\n    mapping(string => bool) public availableSkills; // skillId => isAvailable\n    mapping(string => string) public skillProblemStatements; // skillId => problemStatement\n    mapping(address => mapping(string => bool)) public userSkills; // user => skillId => hasSkill\n    string[] public skillList; // Array to iterate over all skills\n\n    uint256 public nextClaimId;\n    uint256 public nextChallengeId;\n\n    constructor() {\n        owner = msg.sender;\n        resolver = msg.sender; // Default resolver is the owner\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    modifier onlyVerifiedUser(string memory _skillId) {\n        require(userSkills[msg.sender][_skillId], \"You must have this skill verified to perform this action\");\n        _;\n    }\n        /**\n     * @dev Set the resolver address (owner only)\n     * @param _newResolver The new resolver address\n     */\n    function setResolver(address _newResolver) public onlyOwner {\n        require(_newResolver != address(0), \"Resolver cannot be zero address\");\n        address oldResolver = resolver;\n        resolver = _newResolver;\n        emit ResolverUpdated(oldResolver, _newResolver);\n    }\n\n    /**\n     * @dev Add a new skill with its problem statement (owner only)\n     * @param _skillId The skill to add (e.g., \"React\", \"Next.js\")\n     * @param _problemStatement The problem statement for this skill\n     */\n    function addSkill(string memory _skillId, string memory _problemStatement) public onlyOwner {\n        require(bytes(_skillId).length > 0, \"Skill ID cannot be empty\");\n        require(bytes(_problemStatement).length > 0, \"Problem statement cannot be empty\");\n        require(!availableSkills[_skillId], \"Skill already exists\");\n\n        availableSkills[_skillId] = true;\n        skillProblemStatements[_skillId] = _problemStatement;\n        skillList.push(_skillId);\n\n        emit SkillAdded(_skillId, _problemStatement);\n    }\n\n    /**\n     * @dev Remove a skill from the available list (owner only)\n     * @param _skillId The skill to remove\n     */\n    function removeSkill(string memory _skillId) public onlyOwner {\n        require(availableSkills[_skillId], \"Skill does not exist\");\n\n        availableSkills[_skillId] = false;\n        delete skillProblemStatements[_skillId];\n\n        // Remove from skillList array\n        for (uint256 i = 0; i < skillList.length; i++) {\n            if (keccak256(bytes(skillList[i])) == keccak256(bytes(_skillId))) {\n                skillList[i] = skillList[skillList.length - 1];\n                skillList.pop();\n                break;\n            }\n        }\n\n        emit SkillRemoved(_skillId);\n    }\n\n    /**\n     * @dev Update problem statement for an existing skill (owner only)\n     * @param _skillId The skill to update\n     * @param _newProblemStatement The new problem statement\n     */\n    function updateProblemStatement(string memory _skillId, string memory _newProblemStatement) public onlyOwner {\n        require(availableSkills[_skillId], \"Skill does not exist\");\n        require(bytes(_newProblemStatement).length > 0, \"Problem statement cannot be empty\");\n        \n        skillProblemStatements[_skillId] = _newProblemStatement;\n    }\n\n    /**\n     * @dev Add multiple skills at once (owner only)\n     * @param _skillIds Array of skills to add\n     * @param _problemStatements Array of problem statements for each skill\n     */\n    function addMultipleSkills(string[] memory _skillIds, string[] memory _problemStatements) public onlyOwner {\n        require(_skillIds.length == _problemStatements.length, \"Arrays must have same length\");\n        \n        for (uint256 i = 0; i < _skillIds.length; i++) {\n            if (bytes(_skillIds[i]).length > 0 && bytes(_problemStatements[i]).length > 0 && !availableSkills[_skillIds[i]]) {\n                availableSkills[_skillIds[i]] = true;\n                skillProblemStatements[_skillIds[i]] = _problemStatements[i];\n                skillList.push(_skillIds[i]);\n                emit SkillAdded(_skillIds[i], _problemStatements[i]);\n            }\n        }\n    }\n\n    /**\n     * @dev Directly assign a skill to a user instantly (owner only)\n     * @param _user The user to assign the skill to\n     * @param _skillId The skill to assign\n     */\n    function directlyAssignSkill(address _user, string memory _skillId) public onlyOwner {\n        require(_user != address(0), \"User address cannot be zero\");\n        require(bytes(_skillId).length > 0, \"Skill ID cannot be empty\");\n        require(availableSkills[_skillId], \"Skill does not exist\");\n        require(!userSkills[_user][_skillId], \"User already has this skill\");\n\n        // Add to verified skills registry\n        _addVerifiedSkill(_user, _skillId);\n\n        emit SkillDirectlyAssigned(_user, _skillId, msg.sender);\n    }\n\n    /**\n     * @dev Directly assign multiple skills to a user instantly (owner only)\n     * @param _user The user to assign the skills to\n     * @param _skillIds Array of skills to assign\n     */\n    function directlyAssignMultipleSkills(address _user, string[] memory _skillIds) public onlyOwner {\n        require(_user != address(0), \"User address cannot be zero\");\n        \n        for (uint256 i = 0; i < _skillIds.length; i++) {\n            if (bytes(_skillIds[i]).length > 0 && availableSkills[_skillIds[i]] && !userSkills[_user][_skillIds[i]]) {\n                _addVerifiedSkill(_user, _skillIds[i]);\n                emit SkillDirectlyAssigned(_user, _skillIds[i], msg.sender);\n            }\n        }\n    }\n        /**\n     * @dev A user calls this to make a new skill claim\n     * @param _skillId The skill being claimed (e.g., \"React\", \"Solidity\")\n     */\n    function stakeClaim(string memory _skillId) public payable {\n        require(msg.value == PREDEFINED_STAKE_AMOUNT, \"Stake amount must be exactly 0.01 ETH\");\n        require(bytes(_skillId).length > 0, \"Skill ID cannot be empty\");\n        require(availableSkills[_skillId], \"Skill is not available for claiming\");\n        require(!userSkills[msg.sender][_skillId], \"You already have this skill verified\");\n\n        string memory problemStatement = skillProblemStatements[_skillId];\n        require(bytes(problemStatement).length > 0, \"Problem statement not set for this skill\");\n\n        nextClaimId++;\n        \n        claims[nextClaimId] = SkillClaim({\n            user: msg.sender,\n            skillId: _skillId,\n            stakeAmount: msg.value,\n            status: Status.PENDING,\n            claimTimestamp: block.timestamp,\n            problemDeadline: block.timestamp + PROBLEM_SOLVING_TIME,\n            challengeDeadline: block.timestamp + PROBLEM_SOLVING_TIME + CHALLENGE_WINDOW,\n            problemSolved: false,\n            problemStatement: problemStatement,\n            solution: \"\"\n        });\n\n        emit ClaimStaked(msg.sender, nextClaimId, _skillId, msg.value, problemStatement);\n    }\n\n    /**\n     * @dev Claimant submits their solution to the problem\n     * @param _claimId The ID of the claim\n     * @param _solution The solution to the problem\n     */\n    function submitSolution(uint256 _claimId, string memory _solution) public {\n        require(_claimId > 0 && _claimId <= nextClaimId, \"Invalid claim ID\");\n        require(claims[_claimId].user == msg.sender, \"Only the claimant can submit solution\");\n        require(claims[_claimId].status == Status.PENDING, \"Claim is not in pending state\");\n        require(block.timestamp <= claims[_claimId].problemDeadline, \"Problem solving time has expired\");\n        require(!claims[_claimId].problemSolved, \"Solution already submitted\");\n        require(bytes(_solution).length > 0, \"Solution cannot be empty\");\n\n        claims[_claimId].problemSolved = true;\n        claims[_claimId].solution = _solution;\n\n        emit ProblemSolved(_claimId, _solution);\n    }\n        /**\n     * @dev Check if a claim should be auto-rejected due to time expiry\n     * @param _claimId The claim ID to check\n     */\n    function checkTimeExpiry(uint256 _claimId) public {\n        require(_claimId > 0 && _claimId <= nextClaimId, \"Invalid claim ID\");\n        \n        SkillClaim storage claim = claims[_claimId];\n        \n        // If problem solving time expired and no solution submitted\n        if (block.timestamp > claim.problemDeadline && !claim.problemSolved && claim.status == Status.PENDING) {\n            claim.status = Status.REJECTED;\n            \n            // Return stake to claimant\n            (bool success, ) = claim.user.call{value: claim.stakeAmount}(\"\");\n            require(success, \"Stake return failed\");\n        }\n        \n        // If challenge window expired and no challenge was made\n        if (block.timestamp > claim.challengeDeadline && claim.status == Status.PENDING && claim.problemSolved) {\n            claim.status = Status.VERIFIED;\n            _addVerifiedSkill(claim.user, claim.skillId);\n            emit SkillVerified(claim.user, claim.skillId);\n        }\n    }\n\n    /**\n     * @dev Another user calls this to challenge an existing claim\n     * @param _claimId The ID of the claim to challenge\n     * @param _reason The reason for the challenge\n     */\n    function challengeClaim(uint256 _claimId, string memory _reason) public payable onlyVerifiedUser(claims[_claimId].skillId) {\n        require(_claimId > 0 && _claimId <= nextClaimId, \"Invalid claim ID\");\n        require(claims[_claimId].status == Status.PENDING, \"Claim is not pending\");\n        require(claims[_claimId].user != msg.sender, \"Cannot challenge your own claim\");\n        require(msg.value == PREDEFINED_STAKE_AMOUNT, \"Challenge stake must be exactly 0.01 ETH\");\n        require(bytes(_reason).length > 0, \"Reason cannot be empty\");\n        require(claims[_claimId].problemSolved, \"Claimant must solve the problem first\");\n        require(block.timestamp <= claims[_claimId].challengeDeadline, \"Challenge window has expired\");\n\n        nextChallengeId++;\n        \n        challenges[nextChallengeId] = Challenge({\n            challenger: msg.sender,\n            stakeAmount: msg.value,\n            reason: _reason,\n            claimId: _claimId,\n            challengeTimestamp: block.timestamp\n        });\n\n        // Update claim status to challenged\n        claims[_claimId].status = Status.CHALLENGED;\n\n        emit ClaimChallenged(msg.sender, _claimId, _reason, msg.value);\n    }\n        /**\n     * @dev Resolver votes on a challenged claim\n     * @param _claimId The ID of the claim to vote on\n     * @param _supportsClaimant Whether the resolver supports the claimant\n     * @param _reasoning The reasoning for the vote\n     */\n    function voteOnChallenge(uint256 _claimId, bool _supportsClaimant, string memory _reasoning) public onlyVerifiedUser(claims[_claimId].skillId) {\n        require(_claimId > 0 && _claimId <= nextClaimId, \"Invalid claim ID\");\n        require(claims[_claimId].status == Status.CHALLENGED, \"Claim is not challenged\");\n        require(bytes(_reasoning).length > 0, \"Reasoning cannot be empty\");\n        require(msg.sender != claims[_claimId].user, \"Claimant cannot vote on their own claim\");\n        \n        // Check if resolver already voted\n        ResolverVote[] storage votes = resolverVotes[_claimId];\n        for (uint256 i = 0; i < votes.length; i++) {\n            require(votes[i].resolver != msg.sender, \"You have already voted on this challenge\");\n        }\n\n        // Add the vote\n        votes.push(ResolverVote({\n            resolver: msg.sender,\n            supportsClaimant: _supportsClaimant,\n            reasoning: _reasoning,\n            timestamp: block.timestamp\n        }));\n\n        emit ResolverVoted(msg.sender, _claimId, _supportsClaimant, _reasoning);\n    }\n\n    /**\n     * @dev Owner resolves a challenge based on resolver votes (for demo purposes)\n     * @param _claimId The ID of the claim to resolve\n     */\n    function resolveChallenge(uint256 _claimId) public onlyOwner {\n        require(_claimId > 0 && _claimId <= nextClaimId, \"Invalid claim ID\");\n        require(claims[_claimId].status == Status.CHALLENGED, \"Claim is not challenged\");\n\n        SkillClaim storage claim = claims[_claimId];\n        ResolverVote[] storage votes = resolverVotes[_claimId];\n        \n        require(votes.length > 0, \"No votes cast yet\");\n\n        // Count votes\n        uint256 claimantVotes = 0;\n        uint256 challengerVotes = 0;\n        \n        for (uint256 i = 0; i < votes.length; i++) {\n            if (votes[i].supportsClaimant) {\n                claimantVotes++;\n            } else {\n                challengerVotes++;\n            }\n        }\n\n        bool claimantWon = claimantVotes > challengerVotes;\n        address winner;\n        uint256 winnerAmount;\n        uint256 platformAmount;\n        uint256 resolverAmount;\n\n        // Find the challenger\n        address challenger;\n        for (uint256 i = 1; i <= nextChallengeId; i++) {\n            if (challenges[i].claimId == _claimId) {\n                challenger = challenges[i].challenger;\n                break;\n            }\n        }\n\n        if (claimantWon) {\n            winner = claim.user;\n            claim.status = Status.VERIFIED;\n            \n            // Add to verified skills registry\n            _addVerifiedSkill(claim.user, claim.skillId);\n            \n            emit SkillVerified(claim.user, claim.skillId);\n\n            // Claimant gets: their own stake + 25% of challenger's stake\n            winnerAmount = claim.stakeAmount + (PREDEFINED_STAKE_AMOUNT * 25) / 100;\n            \n            // Platform gets: 25% of challenger's stake\n            platformAmount = (PREDEFINED_STAKE_AMOUNT * 25) / 100;\n            \n            // Resolver gets: 50% of challenger's stake\n            resolverAmount = (PREDEFINED_STAKE_AMOUNT * 50) / 100;\n        } else {\n            winner = challenger;\n            claim.status = Status.REJECTED;\n            \n            // Challenger gets: their own stake + 25% of claimant's stake\n            winnerAmount = PREDEFINED_STAKE_AMOUNT + (claim.stakeAmount * 25) / 100;\n            \n            // Platform gets: 25% of claimant's stake\n            platformAmount = (claim.stakeAmount * 25) / 100;\n            \n            // Resolver gets: 50% of claimant's stake\n            resolverAmount = (claim.stakeAmount * 50) / 100;\n        }\n\n        // Distribute the stakes\n        if (winnerAmount > 0) {\n            (bool success1, ) = winner.call{value: winnerAmount}(\"\");\n            require(success1, \"Winner transfer failed\");\n        }\n\n        if (platformAmount > 0) {\n            (bool success2, ) = owner.call{value: platformAmount}(\"\");\n            require(success2, \"Platform transfer failed\");\n        }\n\n        if (resolverAmount > 0) {\n            (bool success3, ) = resolver.call{value: resolverAmount}(\"\");\n            require(success3, \"Resolver transfer failed\");\n        }\n\n        uint256 totalDistributed = winnerAmount + platformAmount + resolverAmount;\n        emit ChallengeResolved(_claimId, claimantWon, winner, totalDistributed);\n        emit StakeDistributed(_claimId, winner, winnerAmount, platformAmount, resolverAmount);\n    }\n        /**\n     * @dev Internal function to add a verified skill to the registry\n     * @param _user The user who has the verified skill\n     * @param _skillId The skill that was verified\n     */\n    function _addVerifiedSkill(address _user, string memory _skillId) internal {\n        // Check if user is already in the list for this skill\n        address[] storage skillUsers = verifiedSkills[_skillId];\n        for (uint256 i = 0; i < skillUsers.length; i++) {\n            if (skillUsers[i] == _user) {\n                return; // User already has this skill verified\n            }\n        }\n        \n        // Add user to the skill's verified list\n        skillUsers.push(_user);\n        \n        // Mark skill as verified for the user\n        userSkills[_user][_skillId] = true;\n    }\n\n    /**\n     * @dev Get all available skills\n     * @return Array of skill IDs that are available for claiming\n     */\n    function getAllSkills() public view returns (string[] memory) {\n        return skillList;\n    }\n\n    /**\n     * @dev Check if a skill is available for claiming\n     * @param _skillId The skill to check\n     * @return True if the skill is available\n     */\n    function isSkillAvailable(string memory _skillId) public view returns (bool) {\n        return availableSkills[_skillId];\n    }\n\n    /**\n     * @dev Get the problem statement for a skill\n     * @param _skillId The skill to get problem statement for\n     * @return The problem statement for the skill\n     */\n    function getProblemStatement(string memory _skillId) public view returns (string memory) {\n        require(availableSkills[_skillId], \"Skill does not exist\");\n        return skillProblemStatements[_skillId];\n    }\n\n    /**\n     * @dev Get all users who have verified a specific skill\n     * @param _skillId The skill to query\n     * @return Array of addresses who have verified this skill\n     */\n    function getVerifiedUsersForSkill(string memory _skillId) public view returns (address[] memory) {\n        return verifiedSkills[_skillId];\n    }\n\n    /**\n     * @dev Check if a user has a specific skill verified\n     * @param _user The user to check\n     * @param _skillId The skill to check\n     * @return True if the user has the skill verified\n     */\n    function hasUserSkill(address _user, string memory _skillId) public view returns (bool) {\n        return userSkills[_user][_skillId];\n    }\n\n    /**\n     * @dev Get claim details\n     * @param _claimId The claim ID to query\n     * @return The claim details\n     */\n    function getClaim(uint256 _claimId) public view returns (SkillClaim memory) {\n        require(_claimId > 0 && _claimId <= nextClaimId, \"Invalid claim ID\");\n        return claims[_claimId];\n    }\n\n    /**\n     * @dev Get challenge details for a claim\n     * @param _claimId The claim ID to query\n     * @return The challenge details if exists\n     */\n    function getChallengeForClaim(uint256 _claimId) public view returns (Challenge memory) {\n        require(_claimId > 0 && _claimId <= nextClaimId, \"Invalid claim ID\");\n        \n        for (uint256 i = 1; i <= nextChallengeId; i++) {\n            if (challenges[i].claimId == _claimId) {\n                return challenges[i];\n            }\n        }\n        \n        revert(\"No challenge found for this claim\");\n    }\n\n    /**\n     * @dev Get all votes for a claim\n     * @param _claimId The claim ID to query\n     * @return Array of resolver votes\n     */\n    function getResolverVotes(uint256 _claimId) public view returns (ResolverVote[] memory) {\n        return resolverVotes[_claimId];\n    }\n\n    /**\n     * @dev Get the predefined stake amount\n     * @return The predefined stake amount in wei\n     */\n    function getPredefinedStakeAmount() public pure returns (uint256) {\n        return PREDEFINED_STAKE_AMOUNT;\n    }\n\n    /**\n     * @dev Emergency function to withdraw contract balance (owner only)\n     */\n    function emergencyWithdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No funds to withdraw\");\n        \n        (bool success, ) = owner.call{value: balance}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n}\n\n"
      }
    }
  }
}